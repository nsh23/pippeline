# helper functions

# Determine the name of the data objects.
# @return A character vector with object names
getDataObjs <- function() {
  row <- which( ( options[ , 'Design'] == input$dsg &
                    options[ , 'Location'] == input$loc &
                    options[ , 'Material'] == input$mat &
                    options[ , 'Analysis'] == input$ana ) )
  if( row < 1) {
    showNotification( 'No data found. (Check file with available options?) Error code #1.', type = 'error')
    return( NULL)
  }
  objs <- as.vector( unname( unlist( options[ row, c( 'Obj1', 'Obj2', 'Obj3') ] ) ) )
  objs <- objs[ objs != '']
  return( objs) # fixme
  areReadable = ( file.access( objs, 4) > -1)
  if( sum( areReadable) != length( areReadable) ) {
    showNotification( 'Data source not readable. (Check file with available options?) Error code #2.', type = 'error')
    return( NULL)
  }
} # function getDataObjs

# Format a code line as a comment.
# @param string: Code line
# @return string
cmt <- function( line = '') {
  paste( "#'", line)
}

# Create a list object to store the attributes of a processing step.
# @param string: step label
# @param character vector: step explanation
# @param boolean: true if step is enabled, false otherwise
# @param function which generates a vector with code line strings
# @param arguments to the function call
# @return mixed: list if enabled, NULL otherwise
createStep <- function( label, 
                        explanation = c(), 
                        enabled = FALSE, 
                        generateCode = function(){c()}, 
                        args = list() ) {
  if( enabled)
    list( 
      label = label, 
      expl = explanation, 
      enabled = enabled, 
      code = do.call( generateCode, args)
    )
  else
    NULL
}

# Generate the documentation for all processing steps.
# @param list object with processing pipeline attributes
# @return character vector: code lines
documentSteps <- function( pipeline) {
  doc <- c()
  for( step in pipeline) {
    if( !is.null( step) &&
        step$enabled) {
      doc <- c(
        doc,
        '',
        cmt( paste( '#', step$label) ),
        cmt( step$expl),
        step$code
      )
    }
  }
  return( doc)
} # function documentSteps

# Write the code that instantiates both the processing and documentation of a processing pipeline.
# @param list object with pipeline attributes
# @param string: filename to write the code to
writeScript <- function( pipeline, 
                         scriptFile) {
  pkgInfo = read.dcf( file.path( '..', 'DESCRIPTION'), fields = c( 'Package', 'Version') )
  doc <- c(
    # YAML
    cmt( '---'),
    cmt( paste0( 'title: "', basics$title, '"') ),
    cmt( paste0( 'author: "', input$author, '"') ),
    cmt( paste0( 'date: "', ts, '"') ),
    cmt( '---'),
    # header
    cmt(),
    cmt( 'This document describes how the associated biobank dataset was prepared.'),
    cmt( paste0( 'It was generated by ', basics$appName, ', an application included in the R package ', pkgInfo[ 1], ', version ', pkgInfo[ 2], '.') ),
    cmt( 'See the R directory for documentation and implementation of statistical functions.'),
    cmt(),
    cmt( '***'),
    cmt(),
    cmt( '# Basic choices'),
    cmt( paste( '* Processing description:', input$descr) ),
    cmt( paste( '* Design:', input$dsg) ),
    cmt( paste( '* Probe location:', input$loc) ),
    cmt( paste( '* Biological material:', input$mat) ),
    cmt( paste( '* Genomic analysis:', input$ana) ),
    cmt(),
    cmt( paste0( 'Data source file names are read from file: ', basics$optionsFile, '.') ),
    cmt(),
    cmt( paste0( 'Questionnaire object names are read from file: ', basics$questsFile, '.') ),
    '',
    '# requirements',
    sprintf( 'library(%s)', pkgInfo[ 1] ),
    sprintf( 'library(arrayQualityMetrics)'),
    sprintf( 'library(limma)'),
    sprintf( 'library(lumi)'),
    sprintf( 'library(nlme)'),
    sprintf( 'library(illuminaHumanv3.db)'),
    sprintf( 'library(illuminaHumanv4.db)'),
    sprintf( 'library(lumiHumanIDMapping)'),
    sprintf( 'library(genefilter)'),
    sprintf( 'library(Biobase)'),
    # steps, incl. read and write
    documentSteps( pipeline),
    # footer
    cmt(),
    cmt( '***')
  )
  writeLines( doc, scriptFile)
} # function writeScript

# Build a list object which keeps all pipeline details stored.
# @param list: parameters
# @return list: pipeline attributes
generatePipeline <- function( params) {
  numberOfRuns <- length( params$sourceObjs)
  idxSeq <- 1 : numberOfRuns

  # details for mandatory processing steps
  # step: reading
  generateCode <- function( lobj) {
    code <- c(   # instructions
      sprintf( 'data <- vector("list",length=%d)', numberOfRuns),
      sprintf( 'data[[%d]] <- vector("list",length=2)', idxSeq)
    )
    if( exists( lobj) )
      code <- c(
        code,
        sprintf( 'data[[%d]]$lumi <- get("%s")', idxSeq, lobj)
      )
    else
      code <- c(
        code,
        'stop("Dataset is non-existant. Error code #7.")'
      )
    code
  }
  readStep <- createStep( 'Datasets', 'Reading in datasets', TRUE, generateCode, list( params$sourceObjs[ idxSeq] ) )
  
  # step: combination
  generateCode <- function() {
    if( numberOfRuns > 1) {
      args <- paste( sprintf( 'data[[%d]]', idxSeq), collapse = ',')
      c( sprintf( 'data <- BiocGenerics::combine(%s)', args) )
    } else {
      c( sprintf( 'data <- data[[1]]') )
    }
  }
  combStep <- createStep( 'Combination', 'Combining all runs', TRUE, generateCode)
  
  # step: anonymization
  generateCode <- function() {
    c(
      '## fixme: NR'
    )
  }
  anoStep <- createStep( 'Anonymization', 'Removing all IDs and running numbers', TRUE, generateCode)

  # step: storage
  generateCode <- function( file) {
    if( input$wantProbes)
      code <- c(
        cmt( 'Note: The target data file contains probes.')
      )
    else
      code <- c(
        cmt( 'Note: The target data file contains genes.'),
        'data <- pippeline::mapToGenes(data)'
      )
    code <- c(
      code,
      sprintf( 'saveRDS(data,file="%s")', file)
    )
    code
  }
  writeStep <- createStep( 'Storage', 'Writing processed datasets.', TRUE, generateCode, list( params$targetFile) )
  
  # step: archiving
  generateCode <- function() {
    c(
      cmt(),
      cmt( 'Copying R script (this file), documentation, and generated data into archive.')
    )
  }
  arStep <- createStep( 'Archiving', 'Collecting files', TRUE, generateCode)
  
  # details for non-mandatory processing steps
  # step: control transitions
  generateCode <- function() {
    c(
      '## fixme: UiT'
    )
  }
  exclStep <- createStep( 'Transitions', 'Exclusion of control-case transitions', input$trans, generateCode)

  # step: outliers
  generateCode <- function() {
    code <- c(
      cmt(),
      cmt( paste( 'Description of outliers:', ifelse( input$outlierDescr != '', input$outlierDescr, 'Not available') ) )
    )
    outlierFile <- input$outlierFile$datapath
    if( length( outlierFile) == 0 ||
        as.integer( file.access( outlierFile, mode = 4) ) < 0) {
      code <- c(
        code,
        'stop( "Could not read outliers file. Error code #4.")'
      )
    } else {
      code <- c(
        code,
        sprintf( '# original filename: %s (copied to temporary location)', input$outlierFile$name),
        sprintf( 'outliers <- readRDS("%s")', outlierFile),
        'exprs(data) <- exprs(data)[,-match(outliers,colnames(exprs(data)))]'
      )
    }
    code
  }
  outlStep <- createStep( 'Outliers', 'Removal of outliers', input$outlierEnabled, generateCode)

  # step: background correction
  generateCode <- function() {
    if( exists( input$ctrlProbes) )
      code <- c(
        '# preparing the negative control probes',
        sprintf( 'data[[%d]$negCtrl <- get("%s")', idxSeq, input$ctrlProbes),
        sprintf( 'pIDs <- vector("list",length=%d)', numberOfRuns),
        sprintf( 'pIDs[[%1$d]] <- data[[%1$d]]$negCtrl$ProbeID', idxSeq),
        sprintf( 'data[[%1$d]]$negCtrl <- t(data[[%1$d]]$negCtrl[,-c(1,2)])', idxSeq),
        sprintf( 'colnames(data[[%1$d]]$negCtrl) <- pIDs[[%1$d]]', idxSeq),
        'rm(pIDs)'
      )
    else
      code <- c(
        'stop("Negative control probes are non-existant. Error code #8.")'
      )
    code <- c(
      code,
      '# now correct',
      sprintf( 'data[[%d]]$lumi <- pippeline::performBackgroundCorrection(data[[%1$d]]$lumi,data[[%1$d]]$negCtrl)', idxSeq)
    )
    code
  }
  bcorrStep <- createStep( 'Background correction', 'Perform background correction and remove bad probes', input$corrEnabled, generateCode)
  
  # step: probe filtering
  generateCode <- function() {
    c(
      sprintf( 'pValue <- %1.2f', input$pval),
      sprintf( 'pLimit <- %1.2f', input$plimit),
      'data <- pippeline::filterData(data,pValue,pLimit)'
    ) 
  }
  filtStep <- createStep( 'Probe filtering', 'Filtering based on on pValue and presentLimit', input$filtEnabled, generateCode)
  
  # step: normalization
  generateCode <- function() {
    c(
      sprintf( 'data <- pippeline::normalizeData(data,"%s")', input$nmeth),
      '# have now gene expressions matrix'
    )
  }
  normStep <- createStep( 'Normalization', 'log2 transformation and quantile normalization', input$normEnabled, generateCode)
  
  # step: questionnaires 
  generateCode <- function() {
    if( exists( input$questObj) ) {
      c(
        sprintf( 'quest <- get("%s")', input$questObj),
        '# determine sample ID matches',
        'm <- match(colnames(data), quest$labnr)',
        '# remove now obsolete IDs',
        'quest$labnr <- NULL',
        '# reduce variable set if necessary',
        sprintf( 'qvars <- c(%s)', paste0( '"', paste( as.character(input$questVars), collapse = '","'), '"' ) ),
        '# sew together matches',
        'data <- rbind(data,t(quest)[qvars,m])',
        'rm(qvars,m,quest)'
      )
    } else
      c(
        'stop("Questionnaire object non-existant. Error code #10.")'
      )
  }
  questStep <- createStep( 'Questionnaires', 'Selecting variables from associated questionnaires', input$questEnabled, generateCode)
  
  # now concatenate all steps
  list(
    readStep, # mandatory
    exclStep,
    outlStep,
    bcorrStep,
    combStep, # mandatory
    filtStep,
    normStep,
    questStep,
    anoStep, # mandatory
    writeStep, # mandatory
    arStep # mandatory
  )
} # function generatePipeline

